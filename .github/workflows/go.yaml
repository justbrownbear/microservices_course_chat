name: Go

on:
  push:
    branches: [ develop, master ]
  pull_request:
    branches: [ develop, master ]

env:
  REGISTRY: "cr.selcloud.ru/docker-registry"
  IMAGE_NAME: "chat"
  CONTAINER_NAME: "chat"
  APP_FOLDER: "/root/chat"

jobs:
  # linter:
  #   name: lint
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@v3
  #     - uses: actions/setup-go@v4
  #       with:
  #         go-version: '1.21'
  #         cache: false
  #     - name: golangci-lint
  #       uses: golangci/golangci-lint-action@v3
  #       with:
  #         # Require: The version of golangci-lint to use.
  #         # When `install-mode` is `binary` (default) the value can be v1.2 or v1.2.3 or `latest` to use the latest version.
  #         # When `install-mode` is `goinstall` the value can be v1.2.3, `latest`, or the hash of a commit.
  #         version: v1.53

  #         # Optional: working directory, useful for monorepos
  #         # working-directory: somedir

  #         # Optional: golangci-lint command line arguments.
  #         #
  #         # Note: By default, the `.golangci.yml` file should be at the root of the repository.
  #         # The location of the configuration file can be changed by using `--config=`
  #         args: --timeout=30m --config=./.golangci.pipeline.yaml --issues-exit-code=0

  #         # Optional: show only new issues if it's a pull request. The default value is `false`.
  #         # only-new-issues: true

  #         # Optional: if set to true, then all caching functionality will be completely disabled,
  #         #           takes precedence over all other caching options.
  #         # skip-cache: true

  #         # Optional: if set to true, then the action won't cache or restore ~/go/pkg.
  #         # skip-pkg-cache: true

  #         # Optional: if set to true, then the action won't cache or restore ~/.cache/go-build.
  #         # skip-build-cache: true

  #         # Optional: The mode to install golangci-lint. It can be 'binary' or 'goinstall'.
  #         # install-mode: "goinstall"

  # build-test-and-push:
  #   runs-on: ubuntu-latest
  #   steps:
  #       - uses: actions/checkout@v3

  #       - name: Set up Go
  #         uses: actions/setup-go@v4
  #         with:
  #           go-version: '1.21'
  #           cache-dependency-path: go.sum

  #       - name: Build
  #         run: go build -o ./bin/ -v ./...

  #       - name: Test
  #         run: go test -v ./...

  #       - name: Checkout branch
  #         uses: actions/checkout@v4

  #       - name: Login to Docker Registry
  #         run: docker login -u ${{ secrets.REGISTRY_USERNAME }} -p ${{ secrets.REGISTRY_PASSWORD }} $REGISTRY

  #       - name: Build and Push Docker image
  #         run: |
  #           TAG_NAME=$(echo $GITHUB_SHA | head -c7)
  #           docker buildx create --use
  #           docker buildx build --no-cache --platform linux/amd64 --push --tag $REGISTRY/$IMAGE_NAME:$TAG_NAME .

  deploy-image:
    runs-on: ubuntu-latest
    # needs: build-test-and-push
    steps:
      - name: Checkout branch
        uses: actions/checkout@v4

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Create target directory on server
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USERNAME }}@${{ secrets.SERVER_HOST }} << 'EOF'
            echo "*** mkdir -p $APP_FOLDER"
            env
            mkdir -p $APP_FOLDER
            EOF

      - name: Copy docker-compose.yaml to server
        run: scp -o StrictHostKeyChecking=no docker-compose.yaml ${{ secrets.SSH_USERNAME }}@${{ secrets.SERVER_HOST }}:$APP_FOLDER

      - name: Deploy to server
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USERNAME }}@${{ secrets.SERVER_HOST }} << 'EOF'
            # Set up variables
            TAG_NAME=$(echo $GITHUB_SHA | head -c7)

            # Login into Selectel Registry
            docker login -u ${{ secrets.REGISTRY_USERNAME }} -p ${{ secrets.REGISTRY_PASSWORD }} $REGISTRY

            # Make a configuration file
            touch .env
            echo "POSTGRES_USER=${{ secrets.POSTGRES_USER }}" > .env
            echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" >> .env
            echo "POSTGRES_HOST=${{ secrets.POSTGRES_HOST }}" >> .env
            echo "POSTGRES_PORT=${{ secrets.POSTGRES_PORT }}" >> .env
            echo "POSTGRES_DB=${{ secrets.POSTGRES_DB }}" >> .env
            echo "GRPC_PROTOCOL=${{ secrets.GRPC_PROTOCOL }}" >> .env
            echo "GRPC_HOST=${{ secrets.GRPC_HOST }}" >> .env
            echo "GRPC_PORT=${{ secrets.GRPC_PORT }}" >> .env

            # Run a new container from a new image
            docker compose -f ./docker-compose.yaml up -d
          EOF

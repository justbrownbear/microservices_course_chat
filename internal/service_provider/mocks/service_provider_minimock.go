// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/justbrownbear/microservices_course_chat/internal/service_provider.ServiceProvider -o service_provider_minimock.go -n ServiceProviderMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	chat_service "github.com/justbrownbear/microservices_course_chat/internal/service/chat"
	user_service "github.com/justbrownbear/microservices_course_chat/internal/service/user"
)

// ServiceProviderMock implements service_provider.ServiceProvider
type ServiceProviderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetChatService          func() (c1 chat_service.ChatService)
	inspectFuncGetChatService   func()
	afterGetChatServiceCounter  uint64
	beforeGetChatServiceCounter uint64
	GetChatServiceMock          mServiceProviderMockGetChatService

	funcGetUserService          func() (u1 user_service.UserService)
	inspectFuncGetUserService   func()
	afterGetUserServiceCounter  uint64
	beforeGetUserServiceCounter uint64
	GetUserServiceMock          mServiceProviderMockGetUserService
}

// NewServiceProviderMock returns a mock for service_provider.ServiceProvider
func NewServiceProviderMock(t minimock.Tester) *ServiceProviderMock {
	m := &ServiceProviderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetChatServiceMock = mServiceProviderMockGetChatService{mock: m}

	m.GetUserServiceMock = mServiceProviderMockGetUserService{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceProviderMockGetChatService struct {
	optional           bool
	mock               *ServiceProviderMock
	defaultExpectation *ServiceProviderMockGetChatServiceExpectation
	expectations       []*ServiceProviderMockGetChatServiceExpectation

	expectedInvocations uint64
}

// ServiceProviderMockGetChatServiceExpectation specifies expectation struct of the ServiceProvider.GetChatService
type ServiceProviderMockGetChatServiceExpectation struct {
	mock *ServiceProviderMock

	results *ServiceProviderMockGetChatServiceResults
	Counter uint64
}

// ServiceProviderMockGetChatServiceResults contains results of the ServiceProvider.GetChatService
type ServiceProviderMockGetChatServiceResults struct {
	c1 chat_service.ChatService
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChatService *mServiceProviderMockGetChatService) Optional() *mServiceProviderMockGetChatService {
	mmGetChatService.optional = true
	return mmGetChatService
}

// Expect sets up expected params for ServiceProvider.GetChatService
func (mmGetChatService *mServiceProviderMockGetChatService) Expect() *mServiceProviderMockGetChatService {
	if mmGetChatService.mock.funcGetChatService != nil {
		mmGetChatService.mock.t.Fatalf("ServiceProviderMock.GetChatService mock is already set by Set")
	}

	if mmGetChatService.defaultExpectation == nil {
		mmGetChatService.defaultExpectation = &ServiceProviderMockGetChatServiceExpectation{}
	}

	return mmGetChatService
}

// Inspect accepts an inspector function that has same arguments as the ServiceProvider.GetChatService
func (mmGetChatService *mServiceProviderMockGetChatService) Inspect(f func()) *mServiceProviderMockGetChatService {
	if mmGetChatService.mock.inspectFuncGetChatService != nil {
		mmGetChatService.mock.t.Fatalf("Inspect function is already set for ServiceProviderMock.GetChatService")
	}

	mmGetChatService.mock.inspectFuncGetChatService = f

	return mmGetChatService
}

// Return sets up results that will be returned by ServiceProvider.GetChatService
func (mmGetChatService *mServiceProviderMockGetChatService) Return(c1 chat_service.ChatService) *ServiceProviderMock {
	if mmGetChatService.mock.funcGetChatService != nil {
		mmGetChatService.mock.t.Fatalf("ServiceProviderMock.GetChatService mock is already set by Set")
	}

	if mmGetChatService.defaultExpectation == nil {
		mmGetChatService.defaultExpectation = &ServiceProviderMockGetChatServiceExpectation{mock: mmGetChatService.mock}
	}
	mmGetChatService.defaultExpectation.results = &ServiceProviderMockGetChatServiceResults{c1}
	return mmGetChatService.mock
}

// Set uses given function f to mock the ServiceProvider.GetChatService method
func (mmGetChatService *mServiceProviderMockGetChatService) Set(f func() (c1 chat_service.ChatService)) *ServiceProviderMock {
	if mmGetChatService.defaultExpectation != nil {
		mmGetChatService.mock.t.Fatalf("Default expectation is already set for the ServiceProvider.GetChatService method")
	}

	if len(mmGetChatService.expectations) > 0 {
		mmGetChatService.mock.t.Fatalf("Some expectations are already set for the ServiceProvider.GetChatService method")
	}

	mmGetChatService.mock.funcGetChatService = f
	return mmGetChatService.mock
}

// Times sets number of times ServiceProvider.GetChatService should be invoked
func (mmGetChatService *mServiceProviderMockGetChatService) Times(n uint64) *mServiceProviderMockGetChatService {
	if n == 0 {
		mmGetChatService.mock.t.Fatalf("Times of ServiceProviderMock.GetChatService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChatService.expectedInvocations, n)
	return mmGetChatService
}

func (mmGetChatService *mServiceProviderMockGetChatService) invocationsDone() bool {
	if len(mmGetChatService.expectations) == 0 && mmGetChatService.defaultExpectation == nil && mmGetChatService.mock.funcGetChatService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChatService.mock.afterGetChatServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChatService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChatService implements service_provider.ServiceProvider
func (mmGetChatService *ServiceProviderMock) GetChatService() (c1 chat_service.ChatService) {
	mm_atomic.AddUint64(&mmGetChatService.beforeGetChatServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatService.afterGetChatServiceCounter, 1)

	if mmGetChatService.inspectFuncGetChatService != nil {
		mmGetChatService.inspectFuncGetChatService()
	}

	if mmGetChatService.GetChatServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatService.GetChatServiceMock.defaultExpectation.Counter, 1)

		mm_results := mmGetChatService.GetChatServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatService.t.Fatal("No results are set for the ServiceProviderMock.GetChatService")
		}
		return (*mm_results).c1
	}
	if mmGetChatService.funcGetChatService != nil {
		return mmGetChatService.funcGetChatService()
	}
	mmGetChatService.t.Fatalf("Unexpected call to ServiceProviderMock.GetChatService.")
	return
}

// GetChatServiceAfterCounter returns a count of finished ServiceProviderMock.GetChatService invocations
func (mmGetChatService *ServiceProviderMock) GetChatServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatService.afterGetChatServiceCounter)
}

// GetChatServiceBeforeCounter returns a count of ServiceProviderMock.GetChatService invocations
func (mmGetChatService *ServiceProviderMock) GetChatServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatService.beforeGetChatServiceCounter)
}

// MinimockGetChatServiceDone returns true if the count of the GetChatService invocations corresponds
// the number of defined expectations
func (m *ServiceProviderMock) MinimockGetChatServiceDone() bool {
	if m.GetChatServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatServiceMock.invocationsDone()
}

// MinimockGetChatServiceInspect logs each unmet expectation
func (m *ServiceProviderMock) MinimockGetChatServiceInspect() {
	for _, e := range m.GetChatServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceProviderMock.GetChatService")
		}
	}

	afterGetChatServiceCounter := mm_atomic.LoadUint64(&m.afterGetChatServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatServiceMock.defaultExpectation != nil && afterGetChatServiceCounter < 1 {
		m.t.Error("Expected call to ServiceProviderMock.GetChatService")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatService != nil && afterGetChatServiceCounter < 1 {
		m.t.Error("Expected call to ServiceProviderMock.GetChatService")
	}

	if !m.GetChatServiceMock.invocationsDone() && afterGetChatServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceProviderMock.GetChatService but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatServiceMock.expectedInvocations), afterGetChatServiceCounter)
	}
}

type mServiceProviderMockGetUserService struct {
	optional           bool
	mock               *ServiceProviderMock
	defaultExpectation *ServiceProviderMockGetUserServiceExpectation
	expectations       []*ServiceProviderMockGetUserServiceExpectation

	expectedInvocations uint64
}

// ServiceProviderMockGetUserServiceExpectation specifies expectation struct of the ServiceProvider.GetUserService
type ServiceProviderMockGetUserServiceExpectation struct {
	mock *ServiceProviderMock

	results *ServiceProviderMockGetUserServiceResults
	Counter uint64
}

// ServiceProviderMockGetUserServiceResults contains results of the ServiceProvider.GetUserService
type ServiceProviderMockGetUserServiceResults struct {
	u1 user_service.UserService
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserService *mServiceProviderMockGetUserService) Optional() *mServiceProviderMockGetUserService {
	mmGetUserService.optional = true
	return mmGetUserService
}

// Expect sets up expected params for ServiceProvider.GetUserService
func (mmGetUserService *mServiceProviderMockGetUserService) Expect() *mServiceProviderMockGetUserService {
	if mmGetUserService.mock.funcGetUserService != nil {
		mmGetUserService.mock.t.Fatalf("ServiceProviderMock.GetUserService mock is already set by Set")
	}

	if mmGetUserService.defaultExpectation == nil {
		mmGetUserService.defaultExpectation = &ServiceProviderMockGetUserServiceExpectation{}
	}

	return mmGetUserService
}

// Inspect accepts an inspector function that has same arguments as the ServiceProvider.GetUserService
func (mmGetUserService *mServiceProviderMockGetUserService) Inspect(f func()) *mServiceProviderMockGetUserService {
	if mmGetUserService.mock.inspectFuncGetUserService != nil {
		mmGetUserService.mock.t.Fatalf("Inspect function is already set for ServiceProviderMock.GetUserService")
	}

	mmGetUserService.mock.inspectFuncGetUserService = f

	return mmGetUserService
}

// Return sets up results that will be returned by ServiceProvider.GetUserService
func (mmGetUserService *mServiceProviderMockGetUserService) Return(u1 user_service.UserService) *ServiceProviderMock {
	if mmGetUserService.mock.funcGetUserService != nil {
		mmGetUserService.mock.t.Fatalf("ServiceProviderMock.GetUserService mock is already set by Set")
	}

	if mmGetUserService.defaultExpectation == nil {
		mmGetUserService.defaultExpectation = &ServiceProviderMockGetUserServiceExpectation{mock: mmGetUserService.mock}
	}
	mmGetUserService.defaultExpectation.results = &ServiceProviderMockGetUserServiceResults{u1}
	return mmGetUserService.mock
}

// Set uses given function f to mock the ServiceProvider.GetUserService method
func (mmGetUserService *mServiceProviderMockGetUserService) Set(f func() (u1 user_service.UserService)) *ServiceProviderMock {
	if mmGetUserService.defaultExpectation != nil {
		mmGetUserService.mock.t.Fatalf("Default expectation is already set for the ServiceProvider.GetUserService method")
	}

	if len(mmGetUserService.expectations) > 0 {
		mmGetUserService.mock.t.Fatalf("Some expectations are already set for the ServiceProvider.GetUserService method")
	}

	mmGetUserService.mock.funcGetUserService = f
	return mmGetUserService.mock
}

// Times sets number of times ServiceProvider.GetUserService should be invoked
func (mmGetUserService *mServiceProviderMockGetUserService) Times(n uint64) *mServiceProviderMockGetUserService {
	if n == 0 {
		mmGetUserService.mock.t.Fatalf("Times of ServiceProviderMock.GetUserService mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserService.expectedInvocations, n)
	return mmGetUserService
}

func (mmGetUserService *mServiceProviderMockGetUserService) invocationsDone() bool {
	if len(mmGetUserService.expectations) == 0 && mmGetUserService.defaultExpectation == nil && mmGetUserService.mock.funcGetUserService == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserService.mock.afterGetUserServiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserService.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserService implements service_provider.ServiceProvider
func (mmGetUserService *ServiceProviderMock) GetUserService() (u1 user_service.UserService) {
	mm_atomic.AddUint64(&mmGetUserService.beforeGetUserServiceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserService.afterGetUserServiceCounter, 1)

	if mmGetUserService.inspectFuncGetUserService != nil {
		mmGetUserService.inspectFuncGetUserService()
	}

	if mmGetUserService.GetUserServiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserService.GetUserServiceMock.defaultExpectation.Counter, 1)

		mm_results := mmGetUserService.GetUserServiceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserService.t.Fatal("No results are set for the ServiceProviderMock.GetUserService")
		}
		return (*mm_results).u1
	}
	if mmGetUserService.funcGetUserService != nil {
		return mmGetUserService.funcGetUserService()
	}
	mmGetUserService.t.Fatalf("Unexpected call to ServiceProviderMock.GetUserService.")
	return
}

// GetUserServiceAfterCounter returns a count of finished ServiceProviderMock.GetUserService invocations
func (mmGetUserService *ServiceProviderMock) GetUserServiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserService.afterGetUserServiceCounter)
}

// GetUserServiceBeforeCounter returns a count of ServiceProviderMock.GetUserService invocations
func (mmGetUserService *ServiceProviderMock) GetUserServiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserService.beforeGetUserServiceCounter)
}

// MinimockGetUserServiceDone returns true if the count of the GetUserService invocations corresponds
// the number of defined expectations
func (m *ServiceProviderMock) MinimockGetUserServiceDone() bool {
	if m.GetUserServiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserServiceMock.invocationsDone()
}

// MinimockGetUserServiceInspect logs each unmet expectation
func (m *ServiceProviderMock) MinimockGetUserServiceInspect() {
	for _, e := range m.GetUserServiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ServiceProviderMock.GetUserService")
		}
	}

	afterGetUserServiceCounter := mm_atomic.LoadUint64(&m.afterGetUserServiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserServiceMock.defaultExpectation != nil && afterGetUserServiceCounter < 1 {
		m.t.Error("Expected call to ServiceProviderMock.GetUserService")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserService != nil && afterGetUserServiceCounter < 1 {
		m.t.Error("Expected call to ServiceProviderMock.GetUserService")
	}

	if !m.GetUserServiceMock.invocationsDone() && afterGetUserServiceCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceProviderMock.GetUserService but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserServiceMock.expectedInvocations), afterGetUserServiceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceProviderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetChatServiceInspect()

			m.MinimockGetUserServiceInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceProviderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceProviderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetChatServiceDone() &&
		m.MinimockGetUserServiceDone()
}
